## Технический аудит и план исправлений (tz-fix)

Дата: 2025-10-04

Цель: полный анализ монорепозитория, выявление технических, логических и смысловых несостыковок между backend (sro-backend), административной панелью (admin-panel) и публичным фронтендом (sro-frontend), а также формирование конкретного плана исправлений. Близкий к идеальному эталон — папка `sro-frontend` (по структуре и чистоте).

---

### 1) Обзор репозитория и стека

- **sro-backend (NestJS 11 + Mongoose 8)**: JWT-аутентификация, роли/permissions, модули: `auth, users, content(news, news-category), registry, documents, pages, files, events, inspections, disciplinary-measures, settings`. Глобальный префикс API — `/api` (configurable).
- **admin-panel (Next.js 15, React 19, Tailwind 3.4)**: богато на мок-данные и fallback-логику; `axios`-сервис с интерцептором, локальное хранение токенов `admin_token/admin_refresh_token`; множество страниц/компонентов и сервисов под админ-функции.
- **sro-frontend (Next.js 15, React 19, Tailwind 4)**: лаконичная структура, корректная мета (`app/layout.tsx`), современный стек, минимализм в сервисах. Используется как эталон структурной чистоты.

Ключевые версии: фронты — Next 15 / React 19, но Tailwind: admin-panel — v3, sro-frontend — v4 (несостыковка экосистемы стилей).

---

### 2) База данных (MongoDB, Mongoose) — структура и риски

- Основные схемы: `user, news, news-category, document, file, page, event, event-type, inspection, disciplinary-measure, compensation-fund, site-settings, refresh-token, password-reset-token, login-attempt, log`.
- Важные несостыковки:
  - В `User` схема обязательно поле `name` (string), но в регистрации backend использует `firstName/lastName/middleName` (не соответствует текущей схеме). При строгой схеме Mongoose — риск ошибки валидации/сохранения.
  - `User.role` ограничен enum `UserRole` (SUPER_ADMIN/ADMIN/MODERATOR/EDITOR), но регистрация выставляет `role: 'USER' as any` — значения нет в enum (валидационная ошибка хранения).
  - `permissions` хранится как `string[]`. Наличие `ROLE_PERMISSIONS` в коде не гарантирует заполнение для новых пользователей (нет синхронизации на запись/обновление).
  - В `NewsService.create` без проверки преобразуется `publishedAt: new Date(createNewsDto.publishedAt)` — при отсутствии корректного значения попадёт `Invalid Date`.

Рекомендации DB:
- Привести DTO/схему `User` к единому формату: либо добавить поля `firstName/lastName/...` в схему, либо формировать `name` на бэке из DTO перед сохранением. Исключить `role: 'USER'`; использовать существующие роли или расширить enum согласованно по всем слоям.
- Централизовать присвоение `permissions` по роли на уровне сервиса пользователей/авторизации.
- Валидировать даты (например, `publishedAt`) и приводить значения безопасно.

---

### 3) Аутентификация, авторизация, роли/права

- JWT-стратегия извлекает пользователя и кладёт объект `user` в `request`. В контроллерах используется переменная по-разному: где-то `req.user.userId`, где-то `req.user.id`. Это логическая несостыковка: в `JwtStrategy.validate` возвращается сам пользователь (скорее всего с `_id`), а не объект вида `{ userId }`.
- Backend `AuthService.login/refresh` возвращает поля `access_token` и `refresh_token` (snake_case), а админ-сервис ожидает `token` и `refreshToken` (camelCase) внутри `data`-оболочки. Несовпадение контракта.
- Роли: backend `UserRole` — UPPER_SNAKE_CASE; admin-panel `UserRole` — нижний регистр ('super_admin', ...). В `AuthContext` встречается зашивка строкового `'SUPER_ADMIN' as UserRole` — это противоречит собственному enum в admin-panel.

Рекомендации auth/roles:
- Стандартизировать `request.user`: вернуть из `JwtStrategy.validate` унифицированный тип (например, `{ id, email, role, permissions }`), и везде в контроллерах использовать `req.user.id`.
- Привести формат ответа auth к единому контуру с фронтом: либо backend возвращает `{ data: { token, refreshToken, user } }`, либо фронт адаптирует ответ и не требует `ApiResponse`-обёртки. Желательно единый стандарт Response Envelope во всех эндпоинтах.
- Выравнять enum ролей между фронтом и бэком: либо оба слоя используют одинаковые строковые значения (рекомендуется UPPER_SNAKE_CASE), либо при маппинге приводить значения явно.

---

### 4) API: контракты, покрытия и несоответствия

Общее:
- Backend имеет глобальный префикс `/api`. По умолчанию порт 3000. В admin-panel baseURL по умолчанию `http://localhost:3001/api` — несостыковка портов по умолчанию.
- Формат ответов backend неоднороден: где-то возвращаются сырые сущности/объекты, где-то `{ data, pagination }`, где-то `204 No Content`. Admin-panel местами ожидает `ApiResponse` c `success/data` и местами работает с "сырыми" Axios-ответами — смешанный подход.

Конкретные расхождения (особенно важен блок новостей):
- Admin-panel `newsService` вызывает (примерный список):
  - `GET /news?…` — есть на бэке, возвращает `{ data, pagination }` (OK).
  - `GET /news/public` — на бэке отсутствует.
  - `GET /news/search?q=` — отсутствует.
  - `GET /news/category/:category` — отсутствует.
  - `PATCH /news/:id/status` — отсутствует.
  - `DELETE /news/bulk` — отсутствует.
  - `GET /news/categories` — есть (контроллер `news/categories`).
  - CRUD категорий — есть.

Файлы:
- Загрузка: `POST /files/upload` — есть, но в контроллере используется `req.user.id`, в других контроллерах — `req.user.userId`. Требуется унификация.
- Типы/лимиты файлов дублируются в конфиге и контроллере — риск расхождения.

Страницы/реестр/документы/мероприятия:
- В целом CRUD покрытие есть, но форматы ответов и требования к авторизации отличаются (где-то только `JwtAuthGuard`, где-то ещё `RolesGuard` и `RequirePermissions`). Это требует синхронизации с вызовами на фронте.

Рекомендации API:
- Выровнять эндпоинты под потребности admin-panel: добавить недостающие маршруты для новостей или адаптировать фронтовые сервисы к уже существующим маршрутам бэка.
- Ввести единый формат ответа (Response Envelope), например:
  - `{ success: boolean, data?: any, pagination?: { page, limit, total, totalPages }, message?: string, error?: string }` для 200-х;
  - консистентная обработка 201/204 и ошибок.
- Документировать контракты (OpenAPI/Swagger уже добавлен как зависимость) и автогенерировать коллекции для Postman.

---

### 5) Admin-panel: типы, сервисы, состояние, UI

- Дублирование типов: в `src/types/admin/index.ts` `ApiResponse` объявлен дважды (разные блоки файла) — техническая ошибка типов.
- `UserRole` (admin) — значения в нижнем регистре; повсюду должны применяться только значения enum, а не строковые литералы с привидением типов.
- `AuthContext`:
  - Инициализация и мок-режим логичны, но `getCurrentUser()` в `apiService` возвращает сырой объект пользователя (Axios response.data), тогда как тип метода — `ApiResponse<User>` и в `AuthContext` ожидается `response.success`. Это логическая несостыковка (может падать на реальном API).
  - Обработка refresh-токена в интерцепторе ожидает `response.data.token/refreshToken`, тогда как бэк отдаёт `access_token/refresh_token`.
- Сервисы контента (пример `news.ts`): ожидают множественные эндпоинты, которых на бэке нет; присутствует fallback на мок-данные, из-за чего несоответствия долго остаются незамеченными.
- `menu` функционал полностью на мок-данных — отсутствует серверная реализация (нет модуля `menu` на бэке).

Рекомендации admin-panel:
- Привести типы к единственному источнику правды: удалить дубликаты `ApiResponse`, унифицировать `Pagination` (`pagination` vs `meta`).
- В `apiService` строго типизировать ответы и нормализовать их внутри сервиса (adapter layer), чтобы компоненты всегда получали единый формат.
- Привести `UserRole` к формату бэка (или ввести явный маппинг). Убрать каст `'SUPER_ADMIN' as UserRole`.
- Согласовать эндпоинты с бэком: либо реализовать недостающие маршруты на бэке, либо упростить фронтовые сервисы к реально существующим.

---

### 6) sro-frontend (эталон)

- Плюсы: чистый layout, корректные метаданные, современный Tailwind 4, минимальность и аккуратность структуры, отсутствие "магии" в сервисах.
- Применимость как эталона: рекомендовано подтянуть admin-panel к тем же практикам — единообразный дизайн-токены, Tailwind-конфиг, отказ от лишней логики в UI.

---

### 7) Безопасность и надёжность

- JWT-секреты имеют дефолты в коде (`your-secret-key`) — критично вынести в `.env` и запретить дефолты в прод-сборке.
- CORS по умолчанию `http://localhost:3000` — выровнять со средами, добавить переменные окружения.
- Rate limiting задействован только на `POST /auth/login` — рассмотреть лимитирование чувствительных эндпоинтов (восстановление пароля и др.).
- Загрузка файлов: `memoryStorage`, лимит 10MB, типы проверяются; нет проверки на вирусы/сканирование — рассмотреть интеграции (ClamAV, S3 Object Lambda, др.).
- Логи: много `console.log` в контроллерах — заменить на централизованный логгер (winston уже в зависимостях), убрать шум из продакшена.

---

### 8) Дизайн/UX и фронтовая экосистема

- Tailwind: admin-panel (v3) vs sro-frontend (v4). Рекомендуется унифицировать на v4, привести токены/утилиты, уменьшить CSS-долг.
- Компонентные библиотеки и иконки синхронизировать между фронтами (по возможности), чтобы обеспечить единый UI-словарь.

---

### 9) Матрица несоответствий (где/что/почему/что должно быть)

- Роль пользователя при регистрации (backend):
  - Где: `AuthService.register` → `role: 'USER' as any`.
  - Что: значение отсутствует в enum `UserRole`.
  - Почему: попытка завести "обычного" пользователя, но модель ролей не поддерживает.
  - Должно быть: использовать `UserRole.EDITOR` или расширить enum и согласовать во всех слоях.

- Поля пользователя (backend vs DB):
  - Где: `UsersService.create` хранит как есть, `User` требует `name`.
  - Что: DTO с `firstName/lastName/...` не маппятся на `name`.
  - Почему: несогласованность схемы и DTO.
  - Должно быть: либо изменить схему, либо собрать `name` на сервисе перед сохранением.

- request.user поле:
  - Где: контроллеры используют и `req.user.userId`, и `req.user.id`.
  - Что: несогласованное имя идентификатора.
  - Почему: стратегия возвращает целый объект пользователя.
  - Должно быть: унифицировать до `req.user.id` (или `userId`), гарантировать в стратегии.

- Формат ответов Auth:
  - Где: backend возвращает `access_token/refresh_token`; admin ожидает `token/refreshToken` в `data`.
  - Что: несовпадение ключей и структуры.
  - Почему: нет единого Response Envelope.
  - Должно быть: привести к единому формату или добавить адаптер на фронте.

- Эндпоинты новостей:
  - Где: admin вызывает `/news/public|search|category/:slug|:id/status|/bulk`.
  - Что: на бэке этих маршрутов нет.
  - Почему: разная продуктовая модель или незавершённая реализация.
  - Должно быть: либо реализовать на бэке, либо удалить/адаптировать фронт-сервисы.

- Типы в admin-panel:
  - Где: `src/types/admin/index.ts` — два `ApiResponse`, разная пагинация (`pagination` vs `meta`).
  - Что: дубли и рассинхронизация сигнатур.
  - Почему: исторический рост файла без рефакторинга.
  - Должно быть: единые типы и единый формат пагинации.

- Порты/база URL по умолчанию:
  - Где: backend слушает 3000; admin-panel по умолчанию бьёт в 3001.
  - Что: без `.env` фронт не достучится.
  - Почему: разные дефолты.
  - Должно быть: согласовать дефолты или строго использовать `.env`.

- Tailwind-версии:
  - Где: admin-panel v3; sro-frontend v4.
  - Что: разные API утилит/плагинов.
  - Почему: разные стартовые шаблоны.
  - Должно быть: унифицировать на v4.

---

### 10) Модель контента: выравнивание фронта, админки, БД и API

Ниже — матрица ключевых сущностей, требуемых полей UI (sro-frontend и admin-panel формы), текущих полей БД и предлагаемых DTO/эндпоинтов.

1) Новости (News)
- Фронт (sro-frontend `NewsItem`): `id, title, content, excerpt, publishedAt, updatedAt, author (string), category{ id,name,slug,color,icon,order }, tags[], featured, imageUrl, cover, views, status`.
- Админ-форма (`NewsForm`): `title, excerpt, content, categoryId, status, imageUrl, seoTitle, seoDescription, seoKeywords`.
- БД (`news.schema`): соответствует большинству полей; `author` как ObjectId, `seoKeywords` — string[] (в админке поле строка). Требуется: привести `seoKeywords` к string[] на входе (сплит по запятым) и возвращать массив; в ответах фронту можно дополнительно отдавать `authorName` для удобства.
- Недостающие API под фронт/админку:
  - `GET /news/public?category&featured&limit` — публичный список для главной/новостей.
  - `GET /news/search?q&category&dateFrom&dateTo&tags` — поиск.
  - `GET /news/category/:slug` — выборка по slug.
  - `PATCH /news/:id/status` — смена статуса публикации.
  - `DELETE /news/bulk` — массовое удаление.

2) Категории новостей (NewsCategory)
- Фронт: `id,name,slug,description?,color?,icon?,order`.
- Админ: CRUD + сортировка.
- БД: полностью покрыто. Нужен эндпоинт массового обновления порядка (есть `PATCH 'order/update'`).

3) Мероприятия (Event)
- Фронт: богатая модель с `agenda[]`, `registrationRequired`, `registrationDeadline`, `type`, `status`, `featured`, `tags`, `organizer`, контакты и т.д.
- Админ-форма: поддерживает почти все перечисленное; `type` выбирается из справочника `EventType`.
- БД (`event.schema`): покрытие присутствует, `materials` — ссылки на `DocumentModel`. Согласовать: `seoKeywords` массив строк, унифицировать даты (ISO строки на вход, Date в БД), добавить публичные эндпоинты:
  - `GET /events/public?type&status&featured&dateFrom&dateTo&page&limit`;
  - `GET /events/:id` публичный;
  - `GET /events/calendar?month&year` (если нужен календарь на фронте).

4) Документы (Document)
- Фронт: `Document` с `id,title,description?,category (enum), fileUrl, fileSize, fileType, uploadedAt, updatedAt, version?` + расширенные категории/разделы (у фронта есть `DocumentCategory` и сложные виды документов для UI, но в БД — плоская модель `DocumentModel`).
- Админ `DocumentUpload`: отправляет `file, title, description, category (id), tags[], isPublic, metadata{ author,publisher,language,pages }`.
- БД: категории — enum-значения, а в админке категории представлены как сущности с `id`. Решение: ввести справочник `DocumentCategory` в БД (id, name, slug, order, icon, color) ИЛИ жёстко сопоставлять enum↔id на уровне сервиса админки. Рекомендуется: справочник категорий + миграция, чтобы соответствовать UI.
- API: оставить `POST /files/upload` для бинарников и `POST /documents` для метаданных документа; обеспечить согласование: админ-форма должна получать `categoryId`, а бэк — маппить на фактическую категорию (enum или ref).

5) Страницы (Pages)
- Фронт: в `sro-frontend` явно используются страницы (about, contacts и пр.).
- Админ `PageForm`: `title, slug, content, excerpt?, status, template, seoTitle, seoDescription, seoKeywords, isHomePage, showInMenu, menuOrder, parentId?, imageUrl?, featuredImage?, customFields?, publishedAt?`.
- БД: есть `pages` модуль; проверить соответствие DTO (особенно `template`, `menuOrder`, `isHomePage`, `showInMenu`, `parentId`, изображения). Рекомендация: хранить `template` в enum, `menu` управлять отдельным сервисом, а для фронта отдавать уплощённое дерево меню.
- Эндпоинты: публичные `GET /pages/slug/:slug` и `GET /pages/slugs`, плюс защищённые CRUD. Уже есть.

6) Реестр арбитражных управляющих (Registry)
- Фронт: типы упрощённые (имя, ИНН, номер, статус и пр.), списки/поиск/детали.
- Админ `ArbitratorForm`: очень подробная форма (личные данные, страхование, фонд, юр. блоки). БД-схемы реестра поддерживают ли весь набор? Проверить соответствие DTO/схемы и добавить недостающие поля/индексы (уникальность ИНН и номера реестра), публичные эндпоинты для списка/деталей, приватные — для CRUD и импорта/экспорта (уже реализовано, в том числе CSV/XLSX).

7) Навигация/меню
- Фронт: использует навигацию из `constants/navigation.ts`.
- Админ: `menu` управляет пунктами в мок-режиме (нет бэкенда). Рекомендуется: добавить `menu` сущность в БД (иерархия, order, visibility, external), эндпоинты `GET /menu (public)`, `POST/PATCH/DELETE /admin/menu`.

Итог: после выравнивания моделей выше фронт и админка используют одни и те же DTO, а БД получает валидные и полные данные. Публичные эндпоинты не должны требовать `JwtAuthGuard`.

---

### 11) План исправлений (итеративно, от критичного к менее критичному)

Шаг 1 — Контракты Auth и request.user
- Backend:
  - В `JwtStrategy.validate` возвращать объект `{ id: user._id.toString(), email: user.email, role: user.role, permissions: user.permissions }`.
  - Во всех контроллерах заменить `req.user.userId` → `req.user.id`.
  - Привести ответы `POST /auth/login` и `POST /auth/refresh` к единому формату, например:
    - `{ success: true, data: { token, refreshToken, user } }`.
  - Исключить дефолтные секреты в коде; использовать только ENV.
- Admin-panel:
  - Обновить `apiService` интерцептор и вызовы: ожидать `data.token/refreshToken` вместо snake_case.
  - Привести `getCurrentUser` к единому формату `ApiResponse<User>` или адаптировать `AuthContext` под сырые ответы — выбрать один подход.

Шаг 2 — Пользователь и роли
- Backend:
  - Исправить регистрацию: либо собрать `name` из `firstName/lastName`, либо расширить схему `User` на поля ФИО.
  - Убрать `role: 'USER' as any`; использовать валидную роль из enum.
  - При создании пользователя автоматически проставлять `permissions` исходя из роли (из `ROLE_PERMISSIONS`).
- Admin-panel:
  - Привести `UserRole` к формату бэка или ввести явный маппинг (конвертация туда-обратно в одном месте).
  - Запретить строковые литералы ролей с `as UserRole`.

Шаг 3 — Новости: выровнять API и фронт
- Вариант А (рекомендуется): реализовать на бэке недостающие маршруты, используемые админкой:
  - `GET /news/public`, `GET /news/search`, `GET /news/category/:slug`,
  - `PATCH /news/:id/status`, `DELETE /news/bulk`.
  - Единый формат ответов, пагинация.
- Вариант Б: упростить фронтовые сервисы под текущее покрытие бэка и убрать неиспользуемые маршруты.

Шаг 4 — Формат ответов и типы
- Ввести единый Response Envelope по всем контроллерам (в т.ч. `files`, `pages`, `registry`, и др.) и привести admin-panel типы к нему.
- В `src/types/admin/index.ts`:
  - Удалить дубликат `ApiResponse`.
  - Стандартизировать `Pagination` (одно имя и одна форма), обновить все сервисы.

Шаг 5 — Инфраструктура и безопасность
- Согласовать порты и `NEXT_PUBLIC_API_URL` в `.env` для локальной разработки.
- Усилить CORS-конфигурацию по окружениям.
- Добавить антивирус/сканирование на загрузку файлов (опционально), ограничивать расширения/контент-тип централизованно.
- Убрать `console.log` из прод-веток, использовать централизованный логгер.

Шаг 6 — UI экосистема
- Перевести admin-panel на Tailwind v4 (как в sro-frontend), синхронизировать дизайн-токены/утилиты.
- Синхронизировать набор компонентных библиотек и иконок (где возможно).

Шаг 7 — Документация и тесты
- Включить Swagger и поддерживать актуальность контрактов.
- Сгенерировать Postman-коллекции (docs/ уже есть), покрыть интеграционными тестами критичные пути (auth, news, files).

---

### 12) Быстрые выигрыши (quick wins)

- Исправить `AuthContext` и `apiService.getCurrentUser()` на единый контракт ответа.
- Привести `req.user` к единому виду и заменить обращения в контроллерах.
- Удалить дубликат `ApiResponse` из админ-типов.
- В `.env` задать один порт API и `NEXT_PUBLIC_API_URL` для фронта.

---

### 13) Приложения

- Список ключевых контроллеров бэка (для трассировки): `auth, users, content/news, content/news-category, documents, events, registry, inspections, disciplinary-measures, pages, files, settings`.
- Главные конфиги: `app.config.ts` (порт, CORS, префикс), `jwt.config.ts` (секреты), `files.config.ts` (пути и типы), `database.config.ts` (URI MongoDB).
- Tailwind: admin-panel — `tailwind.config.js` (v3), sro-frontend — `tailwind.config.ts` (v4).

---

Если нужна детальная матрица полей по каждому эндпоинту (DTO ↔ ответ ↔ UI-форма), готов дополнить файл секциями на основе приоритетов.


